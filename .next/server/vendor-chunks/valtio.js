"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valtio";
exports.ids = ["vendor-chunks/valtio"];
exports.modules = {

/***/ "(ssr)/./node_modules/valtio/esm/vanilla.mjs":
/*!*********************************************!*\
  !*** ./node_modules/valtio/esm/vanilla.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   unstable_buildProxyFunction: () => (/* binding */ unstable_buildProxyFunction)\n/* harmony export */ });\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.modern.js\");\n\nconst isObject = (x)=>typeof x === \"object\" && x !== null;\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler)=>new Proxy(target, handler), canProxy = (x)=>isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), shouldTrapDefineProperty = (desc)=>desc.configurable && desc.enumerable && desc.writable, defaultHandlePromise = (promise)=>{\n    switch(promise.status){\n        case \"fulfilled\":\n            return promise.value;\n        case \"rejected\":\n            throw promise.reason;\n        default:\n            throw promise;\n    }\n}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise)=>{\n    const cache = snapCache.get(target);\n    if ((cache == null ? void 0 : cache[0]) === version) {\n        return cache[1];\n    }\n    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n    (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);\n    snapCache.set(target, [\n        version,\n        snap\n    ]);\n    Reflect.ownKeys(target).forEach((key)=>{\n        if (Object.getOwnPropertyDescriptor(snap, key)) {\n            return;\n        }\n        const value = Reflect.get(target, key);\n        const desc = {\n            value,\n            enumerable: true,\n            // This is intentional to avoid copying with proxy-compare.\n            // It's still non-writable, so it avoids assigning a value.\n            configurable: true\n        };\n        if (refSet.has(value)) {\n            (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);\n        } else if (value instanceof Promise) {\n            delete desc.value;\n            desc.get = ()=>handlePromise(value);\n        } else if (proxyStateMap.has(value)) {\n            const [target2, ensureVersion] = proxyStateMap.get(value);\n            desc.value = createSnapshot(target2, ensureVersion(), handlePromise);\n        }\n        Object.defineProperty(snap, key, desc);\n    });\n    return Object.preventExtensions(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [\n    1,\n    1\n], proxyFunction = (initialObject)=>{\n    if (!isObject(initialObject)) {\n        throw new Error(\"object required\");\n    }\n    const found = proxyCache.get(initialObject);\n    if (found) {\n        return found;\n    }\n    let version = versionHolder[0];\n    const listeners = /* @__PURE__ */ new Set();\n    const notifyUpdate = (op, nextVersion = ++versionHolder[0])=>{\n        if (version !== nextVersion) {\n            version = nextVersion;\n            listeners.forEach((listener)=>listener(op, nextVersion));\n        }\n    };\n    let checkVersion = versionHolder[1];\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1])=>{\n        if (checkVersion !== nextCheckVersion && !listeners.size) {\n            checkVersion = nextCheckVersion;\n            propProxyStates.forEach(([propProxyState])=>{\n                const propVersion = propProxyState[1](nextCheckVersion);\n                if (propVersion > version) {\n                    version = propVersion;\n                }\n            });\n        }\n        return version;\n    };\n    const createPropListener = (prop)=>(op, nextVersion)=>{\n            const newOp = [\n                ...op\n            ];\n            newOp[1] = [\n                prop,\n                ...newOp[1]\n            ];\n            notifyUpdate(newOp, nextVersion);\n        };\n    const propProxyStates = /* @__PURE__ */ new Map();\n    const addPropListener = (prop, propProxyState)=>{\n        if (( false ? 0 : void 0) !== \"production\" && propProxyStates.has(prop)) {\n            throw new Error(\"prop listener already exists\");\n        }\n        if (listeners.size) {\n            const remove = propProxyState[3](createPropListener(prop));\n            propProxyStates.set(prop, [\n                propProxyState,\n                remove\n            ]);\n        } else {\n            propProxyStates.set(prop, [\n                propProxyState\n            ]);\n        }\n    };\n    const removePropListener = (prop)=>{\n        var _a;\n        const entry = propProxyStates.get(prop);\n        if (entry) {\n            propProxyStates.delete(prop);\n            (_a = entry[1]) == null ? void 0 : _a.call(entry);\n        }\n    };\n    const addListener = (listener)=>{\n        listeners.add(listener);\n        if (listeners.size === 1) {\n            propProxyStates.forEach(([propProxyState, prevRemove], prop)=>{\n                if (( false ? 0 : void 0) !== \"production\" && prevRemove) {\n                    throw new Error(\"remove already exists\");\n                }\n                const remove = propProxyState[3](createPropListener(prop));\n                propProxyStates.set(prop, [\n                    propProxyState,\n                    remove\n                ]);\n            });\n        }\n        const removeListener = ()=>{\n            listeners.delete(listener);\n            if (listeners.size === 0) {\n                propProxyStates.forEach(([propProxyState, remove], prop)=>{\n                    if (remove) {\n                        remove();\n                        propProxyStates.set(prop, [\n                            propProxyState\n                        ]);\n                    }\n                });\n            }\n        };\n        return removeListener;\n    };\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n    const trapSet = (hasPrevValue, prevValue, prop, value, setValue)=>{\n        if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n            return;\n        }\n        removePropListener(prop);\n        if (isObject(value)) {\n            value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;\n        }\n        let nextValue = value;\n        if (value instanceof Promise) {\n            value.then((v)=>{\n                value.status = \"fulfilled\";\n                value.value = v;\n                notifyUpdate([\n                    \"resolve\",\n                    [\n                        prop\n                    ],\n                    v\n                ]);\n            }).catch((e)=>{\n                value.status = \"rejected\";\n                value.reason = e;\n                notifyUpdate([\n                    \"reject\",\n                    [\n                        prop\n                    ],\n                    e\n                ]);\n            });\n        } else {\n            if (!proxyStateMap.has(value) && canProxy(value)) {\n                nextValue = proxyFunction(value);\n            }\n            const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n            if (childProxyState) {\n                addPropListener(prop, childProxyState);\n            }\n        }\n        setValue(nextValue);\n        notifyUpdate([\n            \"set\",\n            [\n                prop\n            ],\n            value,\n            prevValue\n        ]);\n    };\n    const handler = {\n        deleteProperty (target, prop) {\n            const prevValue = Reflect.get(target, prop);\n            removePropListener(prop);\n            const deleted = Reflect.deleteProperty(target, prop);\n            if (deleted) {\n                notifyUpdate([\n                    \"delete\",\n                    [\n                        prop\n                    ],\n                    prevValue\n                ]);\n            }\n            return deleted;\n        },\n        set (target, prop, value, receiver) {\n            const hasPrevValue = Reflect.has(target, prop);\n            const prevValue = Reflect.get(target, prop, receiver);\n            trapSet(hasPrevValue, prevValue, prop, value, (nextValue)=>{\n                Reflect.set(target, prop, nextValue, receiver);\n            });\n            return true;\n        },\n        defineProperty (target, prop, desc) {\n            if (shouldTrapDefineProperty(desc)) {\n                const prevDesc = Reflect.getOwnPropertyDescriptor(target, prop);\n                if (!prevDesc || shouldTrapDefineProperty(prevDesc)) {\n                    trapSet(!!prevDesc && \"value\" in prevDesc, prevDesc == null ? void 0 : prevDesc.value, prop, desc.value, (nextValue)=>{\n                        Reflect.defineProperty(target, prop, {\n                            ...desc,\n                            value: nextValue\n                        });\n                    });\n                    return true;\n                }\n            }\n            return Reflect.defineProperty(target, prop, desc);\n        }\n    };\n    const proxyObject = newProxy(baseObject, handler);\n    proxyCache.set(initialObject, proxyObject);\n    const proxyState = [\n        baseObject,\n        ensureVersion,\n        createSnapshot,\n        addListener\n    ];\n    proxyStateMap.set(proxyObject, proxyState);\n    Reflect.ownKeys(initialObject).forEach((key)=>{\n        const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n        if (\"value\" in desc) {\n            proxyObject[key] = initialObject[key];\n            delete desc.value;\n            delete desc.writable;\n        }\n        Object.defineProperty(baseObject, key, desc);\n    });\n    return proxyObject;\n})=>[\n        // public functions\n        proxyFunction,\n        // shared state\n        proxyStateMap,\n        refSet,\n        // internal things\n        objectIs,\n        newProxy,\n        canProxy,\n        shouldTrapDefineProperty,\n        defaultHandlePromise,\n        snapCache,\n        createSnapshot,\n        proxyCache,\n        versionHolder\n    ];\nconst [defaultProxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n    return defaultProxyFunction(initialObject);\n}\nfunction getVersion(proxyObject) {\n    const proxyState = proxyStateMap.get(proxyObject);\n    return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n    const proxyState = proxyStateMap.get(proxyObject);\n    if (( false ? 0 : void 0) !== \"production\" && !proxyState) {\n        console.warn(\"Please use proxy object\");\n    }\n    let promise;\n    const ops = [];\n    const addListener = proxyState[3];\n    let isListenerActive = false;\n    const listener = (op)=>{\n        ops.push(op);\n        if (notifyInSync) {\n            callback(ops.splice(0));\n            return;\n        }\n        if (!promise) {\n            promise = Promise.resolve().then(()=>{\n                promise = void 0;\n                if (isListenerActive) {\n                    callback(ops.splice(0));\n                }\n            });\n        }\n    };\n    const removeListener = addListener(listener);\n    isListenerActive = true;\n    return ()=>{\n        isListenerActive = false;\n        removeListener();\n    };\n}\nfunction snapshot(proxyObject, handlePromise) {\n    const proxyState = proxyStateMap.get(proxyObject);\n    if (( false ? 0 : void 0) !== \"production\" && !proxyState) {\n        console.warn(\"Please use proxy object\");\n    }\n    const [target, ensureVersion, createSnapshot] = proxyState;\n    return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n    refSet.add(obj);\n    return obj;\n}\nconst unstable_buildProxyFunction = buildProxyFunction;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBRTFELE1BQU1FLFdBQVcsQ0FBQ0MsSUFBTSxPQUFPQSxNQUFNLFlBQVlBLE1BQU07QUFDdkQsTUFBTUMsZ0JBQWdCLGFBQWEsR0FBRyxJQUFJQztBQUMxQyxNQUFNQyxTQUFTLGFBQWEsR0FBRyxJQUFJQztBQUNuQyxNQUFNQyxxQkFBcUIsQ0FBQ0MsV0FBV0MsT0FBT0MsRUFBRSxFQUFFQyxXQUFXLENBQUNDLFFBQVFDLFVBQVksSUFBSUMsTUFBTUYsUUFBUUMsUUFBUSxFQUFFRSxXQUFXLENBQUNiLElBQU1ELFNBQVNDLE1BQU0sQ0FBQ0csT0FBT1csR0FBRyxDQUFDZCxNQUFPZSxDQUFBQSxNQUFNQyxPQUFPLENBQUNoQixNQUFNLENBQUVpQixDQUFBQSxPQUFPQyxRQUFRLElBQUlsQixDQUFBQSxDQUFDLEtBQU0sQ0FBRUEsQ0FBQUEsYUFBYUUsT0FBTSxLQUFNLENBQUVGLENBQUFBLGFBQWFJLE9BQU0sS0FBTSxDQUFFSixDQUFBQSxhQUFhbUIsS0FBSSxLQUFNLENBQUVuQixDQUFBQSxhQUFhb0IsTUFBSyxLQUFNLENBQUVwQixDQUFBQSxhQUFhcUIsSUFBRyxLQUFNLENBQUVyQixDQUFBQSxhQUFhc0IsTUFBSyxLQUFNLENBQUV0QixDQUFBQSxhQUFhdUIsTUFBSyxLQUFNLENBQUV2QixDQUFBQSxhQUFhd0IsV0FBVSxDQUFFLEVBQUVDLDJCQUEyQixDQUFDQyxPQUFTQSxLQUFLQyxZQUFZLElBQUlELEtBQUtFLFVBQVUsSUFBSUYsS0FBS0csUUFBUSxFQUFFQyx1QkFBdUIsQ0FBQ0M7SUFDdGhCLE9BQVFBLFFBQVFDLE1BQU07UUFDcEIsS0FBSztZQUNILE9BQU9ELFFBQVFFLEtBQUs7UUFDdEIsS0FBSztZQUNILE1BQU1GLFFBQVFHLE1BQU07UUFDdEI7WUFDRSxNQUFNSDtJQUNWO0FBQ0YsQ0FBQyxFQUFFSSxZQUFZLGFBQWEsR0FBRyxJQUFJakMsU0FBUyxFQUFFa0MsaUJBQWlCLENBQUMxQixRQUFRMkIsU0FBU0MsZ0JBQWdCUixvQkFBb0I7SUFDbkgsTUFBTVMsUUFBUUosVUFBVUssR0FBRyxDQUFDOUI7SUFDNUIsSUFBSSxDQUFDNkIsU0FBUyxPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDLEVBQUUsTUFBTUYsU0FBUztRQUNuRCxPQUFPRSxLQUFLLENBQUMsRUFBRTtJQUNqQjtJQUNBLE1BQU1FLE9BQU8xQixNQUFNQyxPQUFPLENBQUNOLFVBQVUsRUFBRSxHQUFHSCxPQUFPbUMsTUFBTSxDQUFDbkMsT0FBT29DLGNBQWMsQ0FBQ2pDO0lBQzlFYiwwREFBV0EsQ0FBQzRDLE1BQU07SUFDbEJOLFVBQVVTLEdBQUcsQ0FBQ2xDLFFBQVE7UUFBQzJCO1FBQVNJO0tBQUs7SUFDckNJLFFBQVFDLE9BQU8sQ0FBQ3BDLFFBQVFxQyxPQUFPLENBQUMsQ0FBQ0M7UUFDL0IsSUFBSXpDLE9BQU8wQyx3QkFBd0IsQ0FBQ1IsTUFBTU8sTUFBTTtZQUM5QztRQUNGO1FBQ0EsTUFBTWYsUUFBUVksUUFBUUwsR0FBRyxDQUFDOUIsUUFBUXNDO1FBQ2xDLE1BQU10QixPQUFPO1lBQ1hPO1lBQ0FMLFlBQVk7WUFDWiwyREFBMkQ7WUFDM0QsMkRBQTJEO1lBQzNERCxjQUFjO1FBQ2hCO1FBQ0EsSUFBSXhCLE9BQU9XLEdBQUcsQ0FBQ21CLFFBQVE7WUFDckJwQywwREFBV0EsQ0FBQ29DLE9BQU87UUFDckIsT0FBTyxJQUFJQSxpQkFBaUJpQixTQUFTO1lBQ25DLE9BQU94QixLQUFLTyxLQUFLO1lBQ2pCUCxLQUFLYyxHQUFHLEdBQUcsSUFBTUYsY0FBY0w7UUFDakMsT0FBTyxJQUFJaEMsY0FBY2EsR0FBRyxDQUFDbUIsUUFBUTtZQUNuQyxNQUFNLENBQUNrQixTQUFTQyxjQUFjLEdBQUduRCxjQUFjdUMsR0FBRyxDQUNoRFA7WUFFRlAsS0FBS08sS0FBSyxHQUFHRyxlQUNYZSxTQUNBQyxpQkFDQWQ7UUFFSjtRQUNBL0IsT0FBTzhDLGNBQWMsQ0FBQ1osTUFBTU8sS0FBS3RCO0lBQ25DO0lBQ0EsT0FBT25CLE9BQU8rQyxpQkFBaUIsQ0FBQ2I7QUFDbEMsQ0FBQyxFQUFFYyxhQUFhLGFBQWEsR0FBRyxJQUFJckQsU0FBUyxFQUFFc0QsZ0JBQWdCO0lBQUM7SUFBRztDQUFFLEVBQUVDLGdCQUFnQixDQUFDQztJQUN0RixJQUFJLENBQUMzRCxTQUFTMkQsZ0JBQWdCO1FBQzVCLE1BQU0sSUFBSXZDLE1BQU07SUFDbEI7SUFDQSxNQUFNd0MsUUFBUUosV0FBV2YsR0FBRyxDQUFDa0I7SUFDN0IsSUFBSUMsT0FBTztRQUNULE9BQU9BO0lBQ1Q7SUFDQSxJQUFJdEIsVUFBVW1CLGFBQWEsQ0FBQyxFQUFFO0lBQzlCLE1BQU1JLFlBQVksYUFBYSxHQUFHLElBQUlDO0lBQ3RDLE1BQU1DLGVBQWUsQ0FBQ0MsSUFBSUMsY0FBYyxFQUFFUixhQUFhLENBQUMsRUFBRTtRQUN4RCxJQUFJbkIsWUFBWTJCLGFBQWE7WUFDM0IzQixVQUFVMkI7WUFDVkosVUFBVWIsT0FBTyxDQUFDLENBQUNrQixXQUFhQSxTQUFTRixJQUFJQztRQUMvQztJQUNGO0lBQ0EsSUFBSUUsZUFBZVYsYUFBYSxDQUFDLEVBQUU7SUFDbkMsTUFBTUosZ0JBQWdCLENBQUNlLG1CQUFtQixFQUFFWCxhQUFhLENBQUMsRUFBRTtRQUMxRCxJQUFJVSxpQkFBaUJDLG9CQUFvQixDQUFDUCxVQUFVUSxJQUFJLEVBQUU7WUFDeERGLGVBQWVDO1lBQ2ZFLGdCQUFnQnRCLE9BQU8sQ0FBQyxDQUFDLENBQUN1QixlQUFlO2dCQUN2QyxNQUFNQyxjQUFjRCxjQUFjLENBQUMsRUFBRSxDQUFDSDtnQkFDdEMsSUFBSUksY0FBY2xDLFNBQVM7b0JBQ3pCQSxVQUFVa0M7Z0JBQ1o7WUFDRjtRQUNGO1FBQ0EsT0FBT2xDO0lBQ1Q7SUFDQSxNQUFNbUMscUJBQXFCLENBQUNDLE9BQVMsQ0FBQ1YsSUFBSUM7WUFDeEMsTUFBTVUsUUFBUTttQkFBSVg7YUFBRztZQUNyQlcsS0FBSyxDQUFDLEVBQUUsR0FBRztnQkFBQ0Q7bUJBQVNDLEtBQUssQ0FBQyxFQUFFO2FBQUM7WUFDOUJaLGFBQWFZLE9BQU9WO1FBQ3RCO0lBQ0EsTUFBTUssa0JBQWtCLGFBQWEsR0FBRyxJQUFJTTtJQUM1QyxNQUFNQyxrQkFBa0IsQ0FBQ0gsTUFBTUg7UUFDN0IsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxnQkFBZ0JELGdCQUFnQnZELEdBQUcsQ0FBQzJELE9BQU87WUFDbkcsTUFBTSxJQUFJdEQsTUFBTTtRQUNsQjtRQUNBLElBQUl5QyxVQUFVUSxJQUFJLEVBQUU7WUFDbEIsTUFBTVcsU0FBU1QsY0FBYyxDQUFDLEVBQUUsQ0FBQ0UsbUJBQW1CQztZQUNwREosZ0JBQWdCekIsR0FBRyxDQUFDNkIsTUFBTTtnQkFBQ0g7Z0JBQWdCUzthQUFPO1FBQ3BELE9BQU87WUFDTFYsZ0JBQWdCekIsR0FBRyxDQUFDNkIsTUFBTTtnQkFBQ0g7YUFBZTtRQUM1QztJQUNGO0lBQ0EsTUFBTVUscUJBQXFCLENBQUNQO1FBQzFCLElBQUlRO1FBQ0osTUFBTUMsUUFBUWIsZ0JBQWdCN0IsR0FBRyxDQUFDaUM7UUFDbEMsSUFBSVMsT0FBTztZQUNUYixnQkFBZ0JjLE1BQU0sQ0FBQ1Y7WUFDdEJRLENBQUFBLEtBQUtDLEtBQUssQ0FBQyxFQUFFLEtBQUssT0FBTyxLQUFLLElBQUlELEdBQUdHLElBQUksQ0FBQ0Y7UUFDN0M7SUFDRjtJQUNBLE1BQU1HLGNBQWMsQ0FBQ3BCO1FBQ25CTCxVQUFVMEIsR0FBRyxDQUFDckI7UUFDZCxJQUFJTCxVQUFVUSxJQUFJLEtBQUssR0FBRztZQUN4QkMsZ0JBQWdCdEIsT0FBTyxDQUFDLENBQUMsQ0FBQ3VCLGdCQUFnQmlCLFdBQVcsRUFBRWQ7Z0JBQ3JELElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCYyxZQUFZO29CQUNwRixNQUFNLElBQUlwRSxNQUFNO2dCQUNsQjtnQkFDQSxNQUFNNEQsU0FBU1QsY0FBYyxDQUFDLEVBQUUsQ0FBQ0UsbUJBQW1CQztnQkFDcERKLGdCQUFnQnpCLEdBQUcsQ0FBQzZCLE1BQU07b0JBQUNIO29CQUFnQlM7aUJBQU87WUFDcEQ7UUFDRjtRQUNBLE1BQU1TLGlCQUFpQjtZQUNyQjVCLFVBQVV1QixNQUFNLENBQUNsQjtZQUNqQixJQUFJTCxVQUFVUSxJQUFJLEtBQUssR0FBRztnQkFDeEJDLGdCQUFnQnRCLE9BQU8sQ0FBQyxDQUFDLENBQUN1QixnQkFBZ0JTLE9BQU8sRUFBRU47b0JBQ2pELElBQUlNLFFBQVE7d0JBQ1ZBO3dCQUNBVixnQkFBZ0J6QixHQUFHLENBQUM2QixNQUFNOzRCQUFDSDt5QkFBZTtvQkFDNUM7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsT0FBT2tCO0lBQ1Q7SUFDQSxNQUFNQyxhQUFhMUUsTUFBTUMsT0FBTyxDQUFDMEMsaUJBQWlCLEVBQUUsR0FBR25ELE9BQU9tQyxNQUFNLENBQUNuQyxPQUFPb0MsY0FBYyxDQUFDZTtJQUMzRixNQUFNZ0MsVUFBVSxDQUFDQyxjQUFjQyxXQUFXbkIsTUFBTXhDLE9BQU80RDtRQUNyRCxJQUFJRixnQkFBaUJyRixDQUFBQSxTQUFTc0YsV0FBVzNELFVBQVVzQixXQUFXekMsR0FBRyxDQUFDbUIsVUFBVTNCLFNBQVNzRixXQUFXckMsV0FBV2YsR0FBRyxDQUFDUCxPQUFNLEdBQUk7WUFDdkg7UUFDRjtRQUNBK0MsbUJBQW1CUDtRQUNuQixJQUFJMUUsU0FBU2tDLFFBQVE7WUFDbkJBLFFBQVFuQywyREFBWUEsQ0FBQ21DLFVBQVVBO1FBQ2pDO1FBQ0EsSUFBSTZELFlBQVk3RDtRQUNoQixJQUFJQSxpQkFBaUJpQixTQUFTO1lBQzVCakIsTUFBTThELElBQUksQ0FBQyxDQUFDQztnQkFDVi9ELE1BQU1ELE1BQU0sR0FBRztnQkFDZkMsTUFBTUEsS0FBSyxHQUFHK0Q7Z0JBQ2RsQyxhQUFhO29CQUFDO29CQUFXO3dCQUFDVztxQkFBSztvQkFBRXVCO2lCQUFFO1lBQ3JDLEdBQUdDLEtBQUssQ0FBQyxDQUFDQztnQkFDUmpFLE1BQU1ELE1BQU0sR0FBRztnQkFDZkMsTUFBTUMsTUFBTSxHQUFHZ0U7Z0JBQ2ZwQyxhQUFhO29CQUFDO29CQUFVO3dCQUFDVztxQkFBSztvQkFBRXlCO2lCQUFFO1lBQ3BDO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQ2pHLGNBQWNhLEdBQUcsQ0FBQ21CLFVBQVVwQixTQUFTb0IsUUFBUTtnQkFDaEQ2RCxZQUFZckMsY0FBY3hCO1lBQzVCO1lBQ0EsTUFBTWtFLGtCQUFrQixDQUFDaEcsT0FBT1csR0FBRyxDQUFDZ0YsY0FBYzdGLGNBQWN1QyxHQUFHLENBQUNzRDtZQUNwRSxJQUFJSyxpQkFBaUI7Z0JBQ25CdkIsZ0JBQWdCSCxNQUFNMEI7WUFDeEI7UUFDRjtRQUNBTixTQUFTQztRQUNUaEMsYUFBYTtZQUFDO1lBQU87Z0JBQUNXO2FBQUs7WUFBRXhDO1lBQU8yRDtTQUFVO0lBQ2hEO0lBQ0EsTUFBTWpGLFVBQVU7UUFDZHlGLGdCQUFlMUYsTUFBTSxFQUFFK0QsSUFBSTtZQUN6QixNQUFNbUIsWUFBWS9DLFFBQVFMLEdBQUcsQ0FBQzlCLFFBQVErRDtZQUN0Q08sbUJBQW1CUDtZQUNuQixNQUFNNEIsVUFBVXhELFFBQVF1RCxjQUFjLENBQUMxRixRQUFRK0Q7WUFDL0MsSUFBSTRCLFNBQVM7Z0JBQ1h2QyxhQUFhO29CQUFDO29CQUFVO3dCQUFDVztxQkFBSztvQkFBRW1CO2lCQUFVO1lBQzVDO1lBQ0EsT0FBT1M7UUFDVDtRQUNBekQsS0FBSWxDLE1BQU0sRUFBRStELElBQUksRUFBRXhDLEtBQUssRUFBRXFFLFFBQVE7WUFDL0IsTUFBTVgsZUFBZTlDLFFBQVEvQixHQUFHLENBQUNKLFFBQVErRDtZQUN6QyxNQUFNbUIsWUFBWS9DLFFBQVFMLEdBQUcsQ0FBQzlCLFFBQVErRCxNQUFNNkI7WUFDNUNaLFFBQVFDLGNBQWNDLFdBQVduQixNQUFNeEMsT0FBTyxDQUFDNkQ7Z0JBQzdDakQsUUFBUUQsR0FBRyxDQUFDbEMsUUFBUStELE1BQU1xQixXQUFXUTtZQUN2QztZQUNBLE9BQU87UUFDVDtRQUNBakQsZ0JBQWUzQyxNQUFNLEVBQUUrRCxJQUFJLEVBQUUvQyxJQUFJO1lBQy9CLElBQUlELHlCQUF5QkMsT0FBTztnQkFDbEMsTUFBTTZFLFdBQVcxRCxRQUFRSSx3QkFBd0IsQ0FBQ3ZDLFFBQVErRDtnQkFDMUQsSUFBSSxDQUFDOEIsWUFBWTlFLHlCQUF5QjhFLFdBQVc7b0JBQ25EYixRQUNFLENBQUMsQ0FBQ2EsWUFBWSxXQUFXQSxVQUN6QkEsWUFBWSxPQUFPLEtBQUssSUFBSUEsU0FBU3RFLEtBQUssRUFDMUN3QyxNQUNBL0MsS0FBS08sS0FBSyxFQUNWLENBQUM2RDt3QkFDQ2pELFFBQVFRLGNBQWMsQ0FBQzNDLFFBQVErRCxNQUFNOzRCQUNuQyxHQUFHL0MsSUFBSTs0QkFDUE8sT0FBTzZEO3dCQUNUO29CQUNGO29CQUVGLE9BQU87Z0JBQ1Q7WUFDRjtZQUNBLE9BQU9qRCxRQUFRUSxjQUFjLENBQUMzQyxRQUFRK0QsTUFBTS9DO1FBQzlDO0lBQ0Y7SUFDQSxNQUFNOEUsY0FBYy9GLFNBQVNnRixZQUFZOUU7SUFDekM0QyxXQUFXWCxHQUFHLENBQUNjLGVBQWU4QztJQUM5QixNQUFNQyxhQUFhO1FBQ2pCaEI7UUFDQXJDO1FBQ0FoQjtRQUNBaUQ7S0FDRDtJQUNEcEYsY0FBYzJDLEdBQUcsQ0FBQzRELGFBQWFDO0lBQy9CNUQsUUFBUUMsT0FBTyxDQUFDWSxlQUFlWCxPQUFPLENBQUMsQ0FBQ0M7UUFDdEMsTUFBTXRCLE9BQU9uQixPQUFPMEMsd0JBQXdCLENBQzFDUyxlQUNBVjtRQUVGLElBQUksV0FBV3RCLE1BQU07WUFDbkI4RSxXQUFXLENBQUN4RCxJQUFJLEdBQUdVLGFBQWEsQ0FBQ1YsSUFBSTtZQUNyQyxPQUFPdEIsS0FBS08sS0FBSztZQUNqQixPQUFPUCxLQUFLRyxRQUFRO1FBQ3RCO1FBQ0F0QixPQUFPOEMsY0FBYyxDQUFDb0MsWUFBWXpDLEtBQUt0QjtJQUN6QztJQUNBLE9BQU84RTtBQUNULENBQUMsR0FBSztRQUNKLG1CQUFtQjtRQUNuQi9DO1FBQ0EsZUFBZTtRQUNmeEQ7UUFDQUU7UUFDQSxrQkFBa0I7UUFDbEJHO1FBQ0FHO1FBQ0FJO1FBQ0FZO1FBQ0FLO1FBQ0FLO1FBQ0FDO1FBQ0FtQjtRQUNBQztLQUNEO0FBQ0QsTUFBTSxDQUFDa0QscUJBQXFCLEdBQUdyRztBQUMvQixTQUFTc0csTUFBTWpELGdCQUFnQixDQUFDLENBQUM7SUFDL0IsT0FBT2dELHFCQUFxQmhEO0FBQzlCO0FBQ0EsU0FBU2tELFdBQVdKLFdBQVc7SUFDN0IsTUFBTUMsYUFBYXhHLGNBQWN1QyxHQUFHLENBQUNnRTtJQUNyQyxPQUFPQyxjQUFjLE9BQU8sS0FBSyxJQUFJQSxVQUFVLENBQUMsRUFBRTtBQUNwRDtBQUNBLFNBQVNJLFVBQVVMLFdBQVcsRUFBRU0sUUFBUSxFQUFFQyxZQUFZO0lBQ3BELE1BQU1OLGFBQWF4RyxjQUFjdUMsR0FBRyxDQUFDZ0U7SUFDckMsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxnQkFBZ0IsQ0FBQ0MsWUFBWTtRQUNyRk8sUUFBUUMsSUFBSSxDQUFDO0lBQ2Y7SUFDQSxJQUFJbEY7SUFDSixNQUFNbUYsTUFBTSxFQUFFO0lBQ2QsTUFBTTdCLGNBQWNvQixVQUFVLENBQUMsRUFBRTtJQUNqQyxJQUFJVSxtQkFBbUI7SUFDdkIsTUFBTWxELFdBQVcsQ0FBQ0Y7UUFDaEJtRCxJQUFJRSxJQUFJLENBQUNyRDtRQUNULElBQUlnRCxjQUFjO1lBQ2hCRCxTQUFTSSxJQUFJRyxNQUFNLENBQUM7WUFDcEI7UUFDRjtRQUNBLElBQUksQ0FBQ3RGLFNBQVM7WUFDWkEsVUFBVW1CLFFBQVFvRSxPQUFPLEdBQUd2QixJQUFJLENBQUM7Z0JBQy9CaEUsVUFBVSxLQUFLO2dCQUNmLElBQUlvRixrQkFBa0I7b0JBQ3BCTCxTQUFTSSxJQUFJRyxNQUFNLENBQUM7Z0JBQ3RCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsTUFBTTdCLGlCQUFpQkgsWUFBWXBCO0lBQ25Da0QsbUJBQW1CO0lBQ25CLE9BQU87UUFDTEEsbUJBQW1CO1FBQ25CM0I7SUFDRjtBQUNGO0FBQ0EsU0FBUytCLFNBQVNmLFdBQVcsRUFBRWxFLGFBQWE7SUFDMUMsTUFBTW1FLGFBQWF4RyxjQUFjdUMsR0FBRyxDQUFDZ0U7SUFDckMsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxnQkFBZ0IsQ0FBQ0MsWUFBWTtRQUNyRk8sUUFBUUMsSUFBSSxDQUFDO0lBQ2Y7SUFDQSxNQUFNLENBQUN2RyxRQUFRMEMsZUFBZWhCLGVBQWUsR0FBR3FFO0lBQ2hELE9BQU9yRSxlQUFlMUIsUUFBUTBDLGlCQUFpQmQ7QUFDakQ7QUFDQSxTQUFTa0YsSUFBSUMsR0FBRztJQUNkdEgsT0FBT21GLEdBQUcsQ0FBQ21DO0lBQ1gsT0FBT0E7QUFDVDtBQUNBLE1BQU1DLDhCQUE4QnJIO0FBRWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5pdC13YWdtaS1ldGhlci1vbGQtdmVyc2lvbi8uL25vZGVfbW9kdWxlcy92YWx0aW8vZXNtL3ZhbmlsbGEubWpzP2MxOWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFya1RvVHJhY2ssIGdldFVudHJhY2tlZCB9IGZyb20gJ3Byb3h5LWNvbXBhcmUnO1xuXG5jb25zdCBpc09iamVjdCA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsO1xuY29uc3QgcHJveHlTdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVmU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jb25zdCBidWlsZFByb3h5RnVuY3Rpb24gPSAob2JqZWN0SXMgPSBPYmplY3QuaXMsIG5ld1Byb3h5ID0gKHRhcmdldCwgaGFuZGxlcikgPT4gbmV3IFByb3h5KHRhcmdldCwgaGFuZGxlciksIGNhblByb3h5ID0gKHgpID0+IGlzT2JqZWN0KHgpICYmICFyZWZTZXQuaGFzKHgpICYmIChBcnJheS5pc0FycmF5KHgpIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIHgpKSAmJiAhKHggaW5zdGFuY2VvZiBXZWFrTWFwKSAmJiAhKHggaW5zdGFuY2VvZiBXZWFrU2V0KSAmJiAhKHggaW5zdGFuY2VvZiBFcnJvcikgJiYgISh4IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhKHggaW5zdGFuY2VvZiBEYXRlKSAmJiAhKHggaW5zdGFuY2VvZiBTdHJpbmcpICYmICEoeCBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgISh4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpLCBzaG91bGRUcmFwRGVmaW5lUHJvcGVydHkgPSAoZGVzYykgPT4gZGVzYy5jb25maWd1cmFibGUgJiYgZGVzYy5lbnVtZXJhYmxlICYmIGRlc2Mud3JpdGFibGUsIGRlZmF1bHRIYW5kbGVQcm9taXNlID0gKHByb21pc2UpID0+IHtcbiAgc3dpdGNoIChwcm9taXNlLnN0YXR1cykge1xuICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IHByb21pc2U7XG4gIH1cbn0sIHNuYXBDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBjcmVhdGVTbmFwc2hvdCA9ICh0YXJnZXQsIHZlcnNpb24sIGhhbmRsZVByb21pc2UgPSBkZWZhdWx0SGFuZGxlUHJvbWlzZSkgPT4ge1xuICBjb25zdCBjYWNoZSA9IHNuYXBDYWNoZS5nZXQodGFyZ2V0KTtcbiAgaWYgKChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGVbMF0pID09PSB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlWzFdO1xuICB9XG4gIGNvbnN0IHNuYXAgPSBBcnJheS5pc0FycmF5KHRhcmdldCkgPyBbXSA6IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICBtYXJrVG9UcmFjayhzbmFwLCB0cnVlKTtcbiAgc25hcENhY2hlLnNldCh0YXJnZXQsIFt2ZXJzaW9uLCBzbmFwXSk7XG4gIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNuYXAsIGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgZGVzYyA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgdG8gYXZvaWQgY29weWluZyB3aXRoIHByb3h5LWNvbXBhcmUuXG4gICAgICAvLyBJdCdzIHN0aWxsIG5vbi13cml0YWJsZSwgc28gaXQgYXZvaWRzIGFzc2lnbmluZyBhIHZhbHVlLlxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBpZiAocmVmU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgIG1hcmtUb1RyYWNrKHZhbHVlLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIGRlbGV0ZSBkZXNjLnZhbHVlO1xuICAgICAgZGVzYy5nZXQgPSAoKSA9PiBoYW5kbGVQcm9taXNlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgY29uc3QgW3RhcmdldDIsIGVuc3VyZVZlcnNpb25dID0gcHJveHlTdGF0ZU1hcC5nZXQoXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgZGVzYy52YWx1ZSA9IGNyZWF0ZVNuYXBzaG90KFxuICAgICAgICB0YXJnZXQyLFxuICAgICAgICBlbnN1cmVWZXJzaW9uKCksXG4gICAgICAgIGhhbmRsZVByb21pc2VcbiAgICAgICk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzbmFwLCBrZXksIGRlc2MpO1xuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhzbmFwKTtcbn0sIHByb3h5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgdmVyc2lvbkhvbGRlciA9IFsxLCAxXSwgcHJveHlGdW5jdGlvbiA9IChpbml0aWFsT2JqZWN0KSA9PiB7XG4gIGlmICghaXNPYmplY3QoaW5pdGlhbE9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgcmVxdWlyZWRcIik7XG4gIH1cbiAgY29uc3QgZm91bmQgPSBwcm94eUNhY2hlLmdldChpbml0aWFsT2JqZWN0KTtcbiAgaWYgKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGxldCB2ZXJzaW9uID0gdmVyc2lvbkhvbGRlclswXTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgbm90aWZ5VXBkYXRlID0gKG9wLCBuZXh0VmVyc2lvbiA9ICsrdmVyc2lvbkhvbGRlclswXSkgPT4ge1xuICAgIGlmICh2ZXJzaW9uICE9PSBuZXh0VmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IG5leHRWZXJzaW9uO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihvcCwgbmV4dFZlcnNpb24pKTtcbiAgICB9XG4gIH07XG4gIGxldCBjaGVja1ZlcnNpb24gPSB2ZXJzaW9uSG9sZGVyWzFdO1xuICBjb25zdCBlbnN1cmVWZXJzaW9uID0gKG5leHRDaGVja1ZlcnNpb24gPSArK3ZlcnNpb25Ib2xkZXJbMV0pID0+IHtcbiAgICBpZiAoY2hlY2tWZXJzaW9uICE9PSBuZXh0Q2hlY2tWZXJzaW9uICYmICFsaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgY2hlY2tWZXJzaW9uID0gbmV4dENoZWNrVmVyc2lvbjtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5mb3JFYWNoKChbcHJvcFByb3h5U3RhdGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BWZXJzaW9uID0gcHJvcFByb3h5U3RhdGVbMV0obmV4dENoZWNrVmVyc2lvbik7XG4gICAgICAgIGlmIChwcm9wVmVyc2lvbiA+IHZlcnNpb24pIHtcbiAgICAgICAgICB2ZXJzaW9uID0gcHJvcFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfTtcbiAgY29uc3QgY3JlYXRlUHJvcExpc3RlbmVyID0gKHByb3ApID0+IChvcCwgbmV4dFZlcnNpb24pID0+IHtcbiAgICBjb25zdCBuZXdPcCA9IFsuLi5vcF07XG4gICAgbmV3T3BbMV0gPSBbcHJvcCwgLi4ubmV3T3BbMV1dO1xuICAgIG5vdGlmeVVwZGF0ZShuZXdPcCwgbmV4dFZlcnNpb24pO1xuICB9O1xuICBjb25zdCBwcm9wUHJveHlTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhZGRQcm9wTGlzdGVuZXIgPSAocHJvcCwgcHJvcFByb3h5U3RhdGUpID0+IHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvcFByb3h5U3RhdGVzLmhhcyhwcm9wKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvcCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5zaXplKSB7XG4gICAgICBjb25zdCByZW1vdmUgPSBwcm9wUHJveHlTdGF0ZVszXShjcmVhdGVQcm9wTGlzdGVuZXIocHJvcCkpO1xuICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZV0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlUHJvcExpc3RlbmVyID0gKHByb3ApID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZW50cnkgPSBwcm9wUHJveHlTdGF0ZXMuZ2V0KHByb3ApO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgcHJvcFByb3h5U3RhdGVzLmRlbGV0ZShwcm9wKTtcbiAgICAgIChfYSA9IGVudHJ5WzFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChlbnRyeSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBhZGRMaXN0ZW5lciA9IChsaXN0ZW5lcikgPT4ge1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGlmIChsaXN0ZW5lcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZSwgcHJldlJlbW92ZV0sIHByb3ApID0+IHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIHByZXZSZW1vdmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlID0gcHJvcFByb3h5U3RhdGVbM10oY3JlYXRlUHJvcExpc3RlbmVyKHByb3ApKTtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSwgcHJvcCkgPT4ge1xuICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICB9O1xuICBjb25zdCBiYXNlT2JqZWN0ID0gQXJyYXkuaXNBcnJheShpbml0aWFsT2JqZWN0KSA/IFtdIDogT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5pdGlhbE9iamVjdCkpO1xuICBjb25zdCB0cmFwU2V0ID0gKGhhc1ByZXZWYWx1ZSwgcHJldlZhbHVlLCBwcm9wLCB2YWx1ZSwgc2V0VmFsdWUpID0+IHtcbiAgICBpZiAoaGFzUHJldlZhbHVlICYmIChvYmplY3RJcyhwcmV2VmFsdWUsIHZhbHVlKSB8fCBwcm94eUNhY2hlLmhhcyh2YWx1ZSkgJiYgb2JqZWN0SXMocHJldlZhbHVlLCBwcm94eUNhY2hlLmdldCh2YWx1ZSkpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW1vdmVQcm9wTGlzdGVuZXIocHJvcCk7XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBnZXRVbnRyYWNrZWQodmFsdWUpIHx8IHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbmV4dFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgdmFsdWUudGhlbigodikgPT4ge1xuICAgICAgICB2YWx1ZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICB2YWx1ZS52YWx1ZSA9IHY7XG4gICAgICAgIG5vdGlmeVVwZGF0ZShbXCJyZXNvbHZlXCIsIFtwcm9wXSwgdl0pO1xuICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdmFsdWUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICB2YWx1ZS5yZWFzb24gPSBlO1xuICAgICAgICBub3RpZnlVcGRhdGUoW1wicmVqZWN0XCIsIFtwcm9wXSwgZV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcHJveHlTdGF0ZU1hcC5oYXModmFsdWUpICYmIGNhblByb3h5KHZhbHVlKSkge1xuICAgICAgICBuZXh0VmFsdWUgPSBwcm94eUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkUHJveHlTdGF0ZSA9ICFyZWZTZXQuaGFzKG5leHRWYWx1ZSkgJiYgcHJveHlTdGF0ZU1hcC5nZXQobmV4dFZhbHVlKTtcbiAgICAgIGlmIChjaGlsZFByb3h5U3RhdGUpIHtcbiAgICAgICAgYWRkUHJvcExpc3RlbmVyKHByb3AsIGNoaWxkUHJveHlTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgbm90aWZ5VXBkYXRlKFtcInNldFwiLCBbcHJvcF0sIHZhbHVlLCBwcmV2VmFsdWVdKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlciA9IHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCk7XG4gICAgICByZW1vdmVQcm9wTGlzdGVuZXIocHJvcCk7XG4gICAgICBjb25zdCBkZWxldGVkID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm90aWZ5VXBkYXRlKFtcImRlbGV0ZVwiLCBbcHJvcF0sIHByZXZWYWx1ZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGNvbnN0IGhhc1ByZXZWYWx1ZSA9IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICBjb25zdCBwcmV2VmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgIHRyYXBTZXQoaGFzUHJldlZhbHVlLCBwcmV2VmFsdWUsIHByb3AsIHZhbHVlLCAobmV4dFZhbHVlKSA9PiB7XG4gICAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgbmV4dFZhbHVlLCByZWNlaXZlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCBkZXNjKSB7XG4gICAgICBpZiAoc2hvdWxkVHJhcERlZmluZVByb3BlcnR5KGRlc2MpKSB7XG4gICAgICAgIGNvbnN0IHByZXZEZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgaWYgKCFwcmV2RGVzYyB8fCBzaG91bGRUcmFwRGVmaW5lUHJvcGVydHkocHJldkRlc2MpKSB7XG4gICAgICAgICAgdHJhcFNldChcbiAgICAgICAgICAgICEhcHJldkRlc2MgJiYgXCJ2YWx1ZVwiIGluIHByZXZEZXNjLFxuICAgICAgICAgICAgcHJldkRlc2MgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZEZXNjLnZhbHVlLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIGRlc2MudmFsdWUsXG4gICAgICAgICAgICAobmV4dFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgLi4uZGVzYyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV4dFZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwgZGVzYyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm94eU9iamVjdCA9IG5ld1Byb3h5KGJhc2VPYmplY3QsIGhhbmRsZXIpO1xuICBwcm94eUNhY2hlLnNldChpbml0aWFsT2JqZWN0LCBwcm94eU9iamVjdCk7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBbXG4gICAgYmFzZU9iamVjdCxcbiAgICBlbnN1cmVWZXJzaW9uLFxuICAgIGNyZWF0ZVNuYXBzaG90LFxuICAgIGFkZExpc3RlbmVyXG4gIF07XG4gIHByb3h5U3RhdGVNYXAuc2V0KHByb3h5T2JqZWN0LCBwcm94eVN0YXRlKTtcbiAgUmVmbGVjdC5vd25LZXlzKGluaXRpYWxPYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgaW5pdGlhbE9iamVjdCxcbiAgICAgIGtleVxuICAgICk7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgICBwcm94eU9iamVjdFtrZXldID0gaW5pdGlhbE9iamVjdFtrZXldO1xuICAgICAgZGVsZXRlIGRlc2MudmFsdWU7XG4gICAgICBkZWxldGUgZGVzYy53cml0YWJsZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJhc2VPYmplY3QsIGtleSwgZGVzYyk7XG4gIH0pO1xuICByZXR1cm4gcHJveHlPYmplY3Q7XG59KSA9PiBbXG4gIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgcHJveHlGdW5jdGlvbixcbiAgLy8gc2hhcmVkIHN0YXRlXG4gIHByb3h5U3RhdGVNYXAsXG4gIHJlZlNldCxcbiAgLy8gaW50ZXJuYWwgdGhpbmdzXG4gIG9iamVjdElzLFxuICBuZXdQcm94eSxcbiAgY2FuUHJveHksXG4gIHNob3VsZFRyYXBEZWZpbmVQcm9wZXJ0eSxcbiAgZGVmYXVsdEhhbmRsZVByb21pc2UsXG4gIHNuYXBDYWNoZSxcbiAgY3JlYXRlU25hcHNob3QsXG4gIHByb3h5Q2FjaGUsXG4gIHZlcnNpb25Ib2xkZXJcbl07XG5jb25zdCBbZGVmYXVsdFByb3h5RnVuY3Rpb25dID0gYnVpbGRQcm94eUZ1bmN0aW9uKCk7XG5mdW5jdGlvbiBwcm94eShpbml0aWFsT2JqZWN0ID0ge30pIHtcbiAgcmV0dXJuIGRlZmF1bHRQcm94eUZ1bmN0aW9uKGluaXRpYWxPYmplY3QpO1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbihwcm94eU9iamVjdCkge1xuICBjb25zdCBwcm94eVN0YXRlID0gcHJveHlTdGF0ZU1hcC5nZXQocHJveHlPYmplY3QpO1xuICByZXR1cm4gcHJveHlTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJveHlTdGF0ZVsxXSgpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHByb3h5T2JqZWN0LCBjYWxsYmFjaywgbm90aWZ5SW5TeW5jKSB7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBwcm94eVN0YXRlTWFwLmdldChwcm94eU9iamVjdCk7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhcHJveHlTdGF0ZSkge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSB1c2UgcHJveHkgb2JqZWN0XCIpO1xuICB9XG4gIGxldCBwcm9taXNlO1xuICBjb25zdCBvcHMgPSBbXTtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBwcm94eVN0YXRlWzNdO1xuICBsZXQgaXNMaXN0ZW5lckFjdGl2ZSA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lciA9IChvcCkgPT4ge1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBpZiAobm90aWZ5SW5TeW5jKSB7XG4gICAgICBjYWxsYmFjayhvcHMuc3BsaWNlKDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIGlmIChpc0xpc3RlbmVyQWN0aXZlKSB7XG4gICAgICAgICAgY2FsbGJhY2sob3BzLnNwbGljZSgwKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGlzTGlzdGVuZXJBY3RpdmUgPSB0cnVlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlzTGlzdGVuZXJBY3RpdmUgPSBmYWxzZTtcbiAgICByZW1vdmVMaXN0ZW5lcigpO1xuICB9O1xufVxuZnVuY3Rpb24gc25hcHNob3QocHJveHlPYmplY3QsIGhhbmRsZVByb21pc2UpIHtcbiAgY29uc3QgcHJveHlTdGF0ZSA9IHByb3h5U3RhdGVNYXAuZ2V0KHByb3h5T2JqZWN0KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFwcm94eVN0YXRlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIHVzZSBwcm94eSBvYmplY3RcIik7XG4gIH1cbiAgY29uc3QgW3RhcmdldCwgZW5zdXJlVmVyc2lvbiwgY3JlYXRlU25hcHNob3RdID0gcHJveHlTdGF0ZTtcbiAgcmV0dXJuIGNyZWF0ZVNuYXBzaG90KHRhcmdldCwgZW5zdXJlVmVyc2lvbigpLCBoYW5kbGVQcm9taXNlKTtcbn1cbmZ1bmN0aW9uIHJlZihvYmopIHtcbiAgcmVmU2V0LmFkZChvYmopO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgdW5zdGFibGVfYnVpbGRQcm94eUZ1bmN0aW9uID0gYnVpbGRQcm94eUZ1bmN0aW9uO1xuXG5leHBvcnQgeyBnZXRWZXJzaW9uLCBwcm94eSwgcmVmLCBzbmFwc2hvdCwgc3Vic2NyaWJlLCB1bnN0YWJsZV9idWlsZFByb3h5RnVuY3Rpb24gfTtcbiJdLCJuYW1lcyI6WyJtYXJrVG9UcmFjayIsImdldFVudHJhY2tlZCIsImlzT2JqZWN0IiwieCIsInByb3h5U3RhdGVNYXAiLCJXZWFrTWFwIiwicmVmU2V0IiwiV2Vha1NldCIsImJ1aWxkUHJveHlGdW5jdGlvbiIsIm9iamVjdElzIiwiT2JqZWN0IiwiaXMiLCJuZXdQcm94eSIsInRhcmdldCIsImhhbmRsZXIiLCJQcm94eSIsImNhblByb3h5IiwiaGFzIiwiQXJyYXkiLCJpc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJFcnJvciIsIk51bWJlciIsIkRhdGUiLCJTdHJpbmciLCJSZWdFeHAiLCJBcnJheUJ1ZmZlciIsInNob3VsZFRyYXBEZWZpbmVQcm9wZXJ0eSIsImRlc2MiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZhdWx0SGFuZGxlUHJvbWlzZSIsInByb21pc2UiLCJzdGF0dXMiLCJ2YWx1ZSIsInJlYXNvbiIsInNuYXBDYWNoZSIsImNyZWF0ZVNuYXBzaG90IiwidmVyc2lvbiIsImhhbmRsZVByb21pc2UiLCJjYWNoZSIsImdldCIsInNuYXAiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsInNldCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiZm9yRWFjaCIsImtleSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlByb21pc2UiLCJ0YXJnZXQyIiwiZW5zdXJlVmVyc2lvbiIsImRlZmluZVByb3BlcnR5IiwicHJldmVudEV4dGVuc2lvbnMiLCJwcm94eUNhY2hlIiwidmVyc2lvbkhvbGRlciIsInByb3h5RnVuY3Rpb24iLCJpbml0aWFsT2JqZWN0IiwiZm91bmQiLCJsaXN0ZW5lcnMiLCJTZXQiLCJub3RpZnlVcGRhdGUiLCJvcCIsIm5leHRWZXJzaW9uIiwibGlzdGVuZXIiLCJjaGVja1ZlcnNpb24iLCJuZXh0Q2hlY2tWZXJzaW9uIiwic2l6ZSIsInByb3BQcm94eVN0YXRlcyIsInByb3BQcm94eVN0YXRlIiwicHJvcFZlcnNpb24iLCJjcmVhdGVQcm9wTGlzdGVuZXIiLCJwcm9wIiwibmV3T3AiLCJNYXAiLCJhZGRQcm9wTGlzdGVuZXIiLCJlbnYiLCJNT0RFIiwicmVtb3ZlIiwicmVtb3ZlUHJvcExpc3RlbmVyIiwiX2EiLCJlbnRyeSIsImRlbGV0ZSIsImNhbGwiLCJhZGRMaXN0ZW5lciIsImFkZCIsInByZXZSZW1vdmUiLCJyZW1vdmVMaXN0ZW5lciIsImJhc2VPYmplY3QiLCJ0cmFwU2V0IiwiaGFzUHJldlZhbHVlIiwicHJldlZhbHVlIiwic2V0VmFsdWUiLCJuZXh0VmFsdWUiLCJ0aGVuIiwidiIsImNhdGNoIiwiZSIsImNoaWxkUHJveHlTdGF0ZSIsImRlbGV0ZVByb3BlcnR5IiwiZGVsZXRlZCIsInJlY2VpdmVyIiwicHJldkRlc2MiLCJwcm94eU9iamVjdCIsInByb3h5U3RhdGUiLCJkZWZhdWx0UHJveHlGdW5jdGlvbiIsInByb3h5IiwiZ2V0VmVyc2lvbiIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwibm90aWZ5SW5TeW5jIiwiY29uc29sZSIsIndhcm4iLCJvcHMiLCJpc0xpc3RlbmVyQWN0aXZlIiwicHVzaCIsInNwbGljZSIsInJlc29sdmUiLCJzbmFwc2hvdCIsInJlZiIsIm9iaiIsInVuc3RhYmxlX2J1aWxkUHJveHlGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/vanilla.mjs\n");

/***/ })

};
;